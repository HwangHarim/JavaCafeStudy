# 비트 조작

---

### 비트 조작

- AND -> &
- OR -> |
- XOR -> ^
- NOT -> ~

### 2의 보수 만들기

> **4비트 기준 예시, 2가지 방법**
> 1. 1번째 자리를 부호를 나타내는 자리(1->-, 0->+)   
>    1. -3을 예로 절댓값 3의 보수는 5이다.
>    2. 5 를 이진수로 표현하면 101이다
>    3. 101 앞에 부로를 붙인다.
>    4. 결론 -> 1101은 -3을 나타내는 수이다.
> 2. 첫번째 조건과 동일하다
>   1. -3의 예로 절댓값 3을 이진수로 011로 변환
>   2. 011을 뒤집어 100으로 바꾸고 1을 더해준다.
>   3. 더한 값에 부호를 붙여준다
>   4. 결론 -> 1101은 -3을 나타내는 수이다.


## 산술 우측 시프트 VS 논리 우측 시프트

> 논리 우측 시프트(>>>)
>   1. 오른쪽으로 비트를 이동하고 빈자리에 0을 넣는다.
> 
> 산술 우측 시프트(>>)
>   1. 오른쪽으로 이동후 빈자리에 1을 넣는다.


## 기본적인 비트 조작: 비트값 확인 및 채워넣기
~~~ java
// 비트값 확인
// 1을 i 만큼 왼쪽으로 shift 하여 0001000 과 같이 만든다 → num과 & 연산을 하여 i 번째 위치 숫자를 제외하고 모두 삭제한다.
// → 이 값이 1이면 num 의 i 번째 비트는 1이 포함된 숫자이고, 0이면 num 의 i 번째는 0이 포함되었다.

boolean getBit(int num, int i) {
    return ((num & (1 << i)) != 0);
}
~~~
~~~ java
// 비트값 채워넣기
// 특정 i 번째 위치에 1을 채워넣는다
// 1을 왼쪽으로 shift 하여 001000 과 같이 만들어 or 연산을 한다. 0인 곳은 기존의 값에 영향을 주지 못하고, i 번째 값은

int setBit(int num, int i) {
    return num | (1 << i);
}
~~~

~~~ java
// 비트값 삭제하기
// 특정 bit 만 삭제한다.
// getBit 를 반대로 했다. 001000 을 ~ 연산자를 사용해 110111 으로 만들어 and 연산을 하여 특정 위치의 bit 를 제거한다

int clearBit(int num, int i) {
    int mask = ~(1 << i);
    return num & mask;
}
~~~
~~~ java
// 최상위 비트에서 i번째 비트까지 모두 삭제하기
// i 번째 bit 를 셋팅하고 -1 을 하면 최상위 부터 i 번째 까지 0으로 채워지고, 그 뒤는 1로 채워진다
// 이 값을 num에 & 연산을 하면 앞을 0 때문에 0으로 지워지고 그 뒤는 모두 1 때문에 그대로 남아 있는다.

int clearBitsFromHead(int num, int i) {
    int mask = (1 << i) - 1;
    return num & mask;
}
~~~
~~~ java
// 0 ~ i 까지의 bit 를 전부 삭제한다.
// 비트가 모두 1 이면 10진수로 -1 이 된다. -1에 i+1 만큼 시프트 시킨 후 그 값을 & 연산한다.

int clearBitFromTail(int num, int i) {
    int mask = (-1 << (i+1));
    return num * mask;
}
~~~
~~~ java
// i번째 bit 를 v로 변경하기
int updateBit(int num, int i, boolean bitIs1) {
    int value = bitIs1 ? 1 : 0;
    int mask = ~(1 << 1);
    return (num & mask) | (value << i);
}
~~~